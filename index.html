<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atlas Sleep: Voice Hypnosis</title>
    <style>
        /* --- SLEEP UI: Deep Red Mode --- */
        body {
            background-color: #000000;
            color: #8a3333; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }

        /* --- STARFIELD --- */
        #stars-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden; z-index: -1;
            opacity: 0.5;
            perspective: 1000px;
        }
        
        .star {
            position: absolute;
            border-radius: 50%;
            background-color: #552222; 
        }

        /* --- BREATHING CORE --- */
        #core {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: #0D0505;
            transition: all 0.5s ease;
            box-shadow: 0 0 20px rgba(40, 10, 10, 0.4);
            margin-bottom: 50px;
            z-index: 1;
        }

        .listening {
            background: #1a0808 !important;
            animation: breathe 4s infinite ease-in-out;
            box-shadow: 0 0 50px rgba(80, 20, 20, 0.3);
        }
        .speaking {
            background: #2b1d10 !important; 
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(100, 60, 20, 0.2);
        }

        @keyframes breathe {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        #status {
            font-size: 20px;
            font-weight: 300;
            color: #8a3333;
            min-height: 24px;
            text-align: center;
            z-index: 1;
            letter-spacing: 1px;
            transition: opacity 1s;
        }

        /* --- CONTROLS --- */
        .controls {
            position: absolute;
            bottom: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 85%;
            max-width: 320px;
            z-index: 2;
            transition: opacity 1s;
        }

        .persistent-controls {
            position: absolute;
            top: 20px; right: 20px;
            display: flex; gap: 10px;
            opacity: 0.4;
            z-index: 2;
        }

        select, button {
            padding: 14px;
            background: #110505;
            color: #8a3333;
            border: 1px solid #331111;
            border-radius: 12px;
            font-size: 15px;
            outline: none;
            cursor: pointer;
        }
        
        button {
            font-weight: 500;
            background: #1a0808;
            transition: background 0.2s;
        }

        button:active { background: #2f0f0f; }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="stars-container"></div>
    <div id="core"></div>
    <div id="status">...</div>

    <div class="persistent-controls">
        <select id="soundSelect" onchange="soundChanged()">
            <option value="none">Silence</option>
            <option value="rain">Deep Rain</option>
            <option value="brown">Brown Noise</option>
        </select>
        <button onclick="toggleSound()" id="soundBtn">Sound: Off</button>
    </div>

    <div class="controls" id="setupPanel">
        <div style="text-align:center; margin-bottom:15px; font-size:13px; color:#622; line-height: 1.5;">
            <strong>Hypnotic Voice Engine</strong><br>
            I will slow down as we play.<br>
            Drifting Mode starts after 60s of silence.
        </div>
        
        <select id="voiceSelect" onchange="testVoice()">
            <option value="">Loading voices...</option>
        </select>
        
        <button onclick="startSession()" style="font-size: 16px; padding: 18px; border: 1px solid #522;">
            Begin Sleep Session
        </button>
    </div>

    <script>
        // --- 0. DATA ---
        const CITIES_DB = [
            "Mumbai", "Delhi", "Bangalore", "Hyderabad", "Ahmedabad", "Chennai", "Kolkata", "Surat", "Pune", "Jaipur", "Lucknow", "Kanpur", "Nagpur", "Indore", "Thane", "Bhopal", "Visakhapatnam", "Pimpri", "Patna", "Vadodara", "Ghaziabad", "Ludhiana", "Agra", "Nashik", "Faridabad", "Meerut", "Rajkot", "Varanasi", "Srinagar", "Aurangabad", "Dhanbad", "Amritsar", "Navi Mumbai", "Allahabad", "Ranchi", "Howrah", "Coimbatore", "Jabalpur", "Gwalior", "Vijayawada", "Jodhpur", "Madurai", "Raipur", "Kota", "Guwahati", "Chandigarh", "Solapur", "Hubli", "Mysore", "Tiruchirappalli", "Bareilly", "Aligarh", "Tiruppur", "Gurgaon", "Moradabad", "Jalandhar", "Bhubaneswar", "Salem", "Warangal", "Thiruvananthapuram", "Bhiwandi", "Saharanpur", "Gorakhpur", "Guntur", "Bikaner", "Amravati", "Noida", "Jamshedpur", "Bhilai", "Cuttack", "Firozabad", "Kochi", "Bhavnagar", "Dehradun", "Durgapur", "Asansol", "Nanded", "Kolhapur", "Ajmer", "Gulbarga", "Jamnagar", "Ujjain", "Loni", "Siliguri", "Jhansi", "Ulhasnagar", "Jammu", "Sangli", "Erode", "Goa", "Anand", "Ratlam", "Moga", "Abohar", "Rewa", "Puri", "Haldwani", "Karnal", "Panipat", "Rohtak", "Hisar", "Shimla", "Manali", "Kullu", "Rishikesh", "Haridwar", "Nainital", "Mussoorie", "Almora", "Pithoragarh", "Champawat", "Bageshwar", "Tezpur", "Imphal", "Shillong", "Aizawl", "Kohima", "Gangtok", "Agartala", "Itanagar", "Dispur", "Dimapur", "Silchar", "Dibrugarh", "Jorhat", "Nagaon", "Tinsukia", "Bongaigaon", "Dhubri", "Diphu", "North Lakhimpur", "Karimganj", "Sibsagar", "Goalpara", "Barpeta", "Lanka", "Hojai", "London", "Paris", "New York", "Tokyo", "Dubai", "Singapore", "Berlin", "Rome", "Madrid", "Moscow", "Toronto", "Sydney", "Melbourne", "Beijing", "Shanghai", "Hong Kong", "Bangkok", "Seoul", "Istanbul", "Cairo", "Rio", "Lima", "Nairobi", "Lagos", "Accra", "Dakar", "Chicago", "Houston", "Phoenix", "Philadelphia", "Dallas", "Austin", "Boston", "Seattle", "Denver", "Miami", "Atlanta", "Detroit", "Minneapolis", "Tampa", "Orlando", "Portland", "Vegas"
        ];

        // --- 1. CONFIG & STATE ---
        const GHOST_TIMEOUT_MS = 60000;   // 60s Drift
        const WARNING_TIMEOUT_MS = 45000; // 45s Warning

        let ghostTimer = null;
        let warningTimer = null;
        let isGhostMode = false;
        
        let turnCount = 0;
        let currentRate = 0.95; // Start nearly normal
        
        let recognition;
        let audioCtx, soundNode;
        let isSoundOn = false;
        const synth = window.speechSynthesis;
        
        let usedWords = new Set();
        let lastLetter = "";
        let isSessionActive = false;

        // --- 2. VISUALS ---
        function createStars() {
            const container = document.getElementById('stars-container');
            for(let i=0; i<120; i++) {
                const s = document.createElement('div');
                s.className = 'star';
                const size = Math.random() * 2;
                s.style.width = size + 'px';
                s.style.height = size + 'px';
                s.style.left = Math.random() * 100 + '%';
                s.style.top = Math.random() * 100 + '%';
                s.style.opacity = Math.random() * 0.4 + 0.1;
                
                const duration = Math.random() * 100 + 100;
                s.style.transition = `transform ${duration}s linear`;
                setTimeout(() => { s.style.transform = `translateY(-100px)`; }, 100);
                
                container.appendChild(s);
            }
        }
        createStars();

        // --- 3. AUDIO ENGINE ---
        function createNoise(type) {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            if (type === 'rain' || type === 'brown') {
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5; 
                }
            }
            return buffer;
        }

        function toggleSound() {
            const btn = document.getElementById('soundBtn');
            if (!isSoundOn) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!audioCtx) audioCtx = new AudioContext();
                audioCtx.resume();
                soundChanged();
                btn.innerText = "Sound: On";
                isSoundOn = true;
            } else {
                if (audioCtx) audioCtx.suspend();
                btn.innerText = "Sound: Off";
                isSoundOn = false;
            }
        }

        function soundChanged() {
            if (!isSoundOn || !audioCtx) return;
            if (soundNode) { try{soundNode.stop();}catch(e){} }
            
            const type = document.getElementById('soundSelect').value;
            if (type === 'none') return;

            const buffer = createNoise(type);
            soundNode = audioCtx.createBufferSource();
            soundNode.buffer = buffer;
            soundNode.loop = true;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 250; 
            
            soundNode.connect(filter);
            filter.connect(audioCtx.destination);
            soundNode.start();
        }

        // --- 4. VOICE ENGINE ---
        function getVoiceScore(voice) {
            let score = 0;
            const name = voice.name;
            if (name.includes("Natural") && name.includes("Online")) score += 20; 
            if (name.includes("Natural")) score += 15;
            if (name.includes("Google") && name.includes("US")) score += 10;
            if (name.includes("Siri")) score += 10;
            if (voice.lang === 'en-US') score += 5;
            return score;
        }

        async function loadVoices() {
            return new Promise(resolve => {
                let v = synth.getVoices();
                if(v.length) resolve(v);
                else synth.onvoiceschanged = () => resolve(synth.getVoices());
            });
        }

        async function initVoices() {
            const voices = await loadVoices();
            const select = document.getElementById('voiceSelect');
            select.innerHTML = '';
            
            const validVoices = voices.filter(v => v.lang.includes('en'));
            validVoices.sort((a, b) => getVoiceScore(b) - getVoiceScore(a));

            if (validVoices.length === 0) {
                const opt = document.createElement('option');
                opt.text = "Default Voice";
                select.appendChild(opt);
                return;
            }

            validVoices.forEach(v => {
                const opt = document.createElement('option');
                opt.value = v.name;
                let label = v.name;
                if (getVoiceScore(v) >= 10) label = "â­ " + label;
                opt.text = label;
                select.appendChild(opt);
            });
            select.selectedIndex = 0;
        }
        initVoices();

        function speak(text, callback) {
            if (!isSessionActive && !text.includes("Voice")) return;
            synth.cancel();
            
            const u = new SpeechSynthesisUtterance(text);
            const voiceName = document.getElementById('voiceSelect').value;
            const voice = synth.getVoices().find(v => v.name === voiceName);
            if(voice) u.voice = voice;

            const isNatural = voiceName.includes("Natural") || voiceName.includes("Google");

            // HYPNOTIC VOICE MODULATION
            if (isNatural) {
                // Natural voices sound best when slowed down naturally
                u.rate = Math.max(0.75, currentRate); 
                u.pitch = 1.0; 
            } else {
                // Robotic voices get deeper and slower
                u.rate = Math.max(0.65, currentRate); 
                u.pitch = Math.max(0.8, 1.0 - (turnCount * 0.02)); 
            }
            u.volume = 0.8;

            document.getElementById('core').className = 'speaking';
            u.onend = () => {
                document.getElementById('core').className = '';
                if(callback) callback();
            };
            synth.speak(u);
        }

        function testVoice() {
            synth.cancel();
            const u = new SpeechSynthesisUtterance("Hypnotic Voice Engine Ready.");
            const voiceName = document.getElementById('voiceSelect').value;
            const voice = synth.getVoices().find(v => v.name === voiceName);
            if(voice) u.voice = voice;
            synth.speak(u);
        }

        // --- 5. GAME LOGIC & HYPNOTIC DELAYS ---
        
        function calculateHypnoticDelay() {
            // Base delay 1.5s
            // Adds 0.5s every turn
            // Caps at 5s
            const delay = 1500 + (turnCount * 500);
            return Math.min(delay, 5000);
        }

        function startSession() {
            document.getElementById('setupPanel').classList.add('hidden');
            isSessionActive = true;
            turnCount = 0;
            currentRate = 0.95;
            
            if ('wakeLock' in navigator) {
                try { navigator.wakeLock.request('screen'); } catch(e){}
            }

            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SR) {
                recognition = new SR();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onresult = handleUserSpeech;
                recognition.onerror = (e) => { 
                    console.log("Mic Error/Silence", e); 
                    if(!isGhostMode) restartListening(); 
                };
            } else {
                alert("Speech Recognition not supported.");
            }
            
            speak("Close your eyes. Relax... I will start. Chicago.", () => {
                usedWords.add("Chicago");
                lastLetter = "o";
                startTurn();
            });
        }

        function startTurn() {
            if (!isSessionActive) return;

            // RESET TIMERS
            clearTimeout(ghostTimer);
            clearTimeout(warningTimer);

            if (!isGhostMode) {
                // Warning at 45s (Soft)
                warningTimer = setTimeout(() => {
                    if(!isGhostMode && isSessionActive) {
                        speak("Are you still with me? ...", restartListening);
                    }
                }, WARNING_TIMEOUT_MS);

                // Drift at 60s
                ghostTimer = setTimeout(enterGhostMode, GHOST_TIMEOUT_MS);
                
                listen();
            } else {
                aiSelfPlay();
            }
        }

        function listen() {
            document.getElementById('core').className = 'listening';
            document.getElementById('status').innerText = "Listening...";
            try { recognition.start(); } catch(e) {}
        }

        function restartListening() {
            if (isSessionActive && !isGhostMode) {
                setTimeout(() => { 
                    try { recognition.start(); } catch(e){} 
                }, 500);
            }
        }

        function handleUserSpeech(event) {
            clearTimeout(ghostTimer); 
            clearTimeout(warningTimer);
            
            const transcript = event.results[0][0].transcript.trim().replace(".","");
            document.getElementById('status').innerText = transcript;
            
            if (transcript.toLowerCase() === "stop") {
                endSession();
                return;
            }

            const city = transcript.split(" ")[0]; 
            
            if (!validateMove(city)) {
                speak(`Try a place starting with ${lastLetter}.`, listen);
                return;
            }

            processValidMove(city);
        }

        function validateMove(rawCity) {
            if (!rawCity) return false;
            return rawCity.toLowerCase().startsWith(lastLetter.toLowerCase());
        }

        function processValidMove(city) {
            const cleanCity = city.charAt(0).toUpperCase() + city.slice(1).toLowerCase();
            usedWords.add(cleanCity);
            const nextChar = cleanCity.slice(-1);
            
            turnCount++;
            
            // HYPNOTIC DECELERATION: Drop speed every 3 turns
            if (turnCount % 3 === 0) currentRate -= 0.05; 

            // HYPNOTIC DELAY: Pause longer as game progresses
            const delay = calculateHypnoticDelay();
            
            setTimeout(() => aiReply(nextChar), delay);
        }

        function aiReply(char) {
            const candidates = CITIES_DB.filter(c => c.toLowerCase().startsWith(char.toLowerCase()) && !usedWords.has(c));
            
            if (candidates.length === 0) {
                // Fallback to random if stuck
                const fallback = CITIES_DB.filter(c => !usedWords.has(c));
                const choice = fallback[Math.floor(Math.random() * fallback.length)];
                speak(`I'll switch to ${choice}. Your turn with ${choice.slice(-1)}.`, startTurn);
                usedWords.add(choice);
                lastLetter = choice.slice(-1);
                return;
            }

            const choice = candidates[Math.floor(Math.random() * candidates.length)];
            usedWords.add(choice);
            lastLetter = choice.slice(-1);
            
            if (isGhostMode) {
                speak(choice, startTurn); 
            } else {
                speak(`${choice}. Your turn with ${lastLetter}.`, startTurn);
            }
        }

        // --- 6. GHOST MODE (Drifting) ---
        function enterGhostMode() {
            if (isGhostMode) return;
            isGhostMode = true;
            document.getElementById('status').innerText = "Drifting...";
            document.getElementById('status').style.opacity = 0.5;
            
            try { recognition.stop(); } catch(e){}

            speak("Drifting off... I will continue...", () => {
                aiSelfPlay();
            });
        }

        function aiSelfPlay() {
            if(!isSessionActive) return;
            
            // In Ghost Mode, the delay is fixed and long (6 seconds)
            // This acts like a rhythmic metronome
            setTimeout(() => {
                const candidates = CITIES_DB.filter(c => c.toLowerCase().startsWith(lastLetter.toLowerCase()) && !usedWords.has(c));
                if(candidates.length > 0) {
                    const choice = candidates[Math.floor(Math.random() * candidates.length)];
                    usedWords.add(choice);
                    lastLetter = choice.slice(-1);
                    
                    document.getElementById('status').innerText = choice;
                    speak(choice, () => {
                        setTimeout(() => aiReply(lastLetter), 2000); 
                    });
                }
            }, 6000); 
        }

        function endSession() {
            isSessionActive = false;
            synth.cancel();
            if(audioCtx) audioCtx.close();
            document.body.innerHTML = ""; 
            document.body.style.backgroundColor = "#000";
        }
    </script>
</body>
</html>